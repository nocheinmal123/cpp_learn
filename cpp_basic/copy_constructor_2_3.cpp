#include <string>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>

/*
class Complex{
    private:
        double real,image;
};

int main(){
    Complex c1; // using the default constructor, which is generated by compiler
    Complex c2(c1); // using the default copy constructor, which is generated by compiler
    return 0;
}
*/

class Complex{
    public:
        double real,image;
    Complex(double real = 0,double image = 0);
    Complex(const Complex &c){
        real = c.real;
        image = c.image;
        std::cout<<"Copy Constructor called."<<std::endl;
    }
};

Complex::Complex(double real,double image){
    std::cout<<"Constructor called"<<std::endl;
    real = real;
    image = image;
}

/*
When does copy constructor work?
    1. using a object to initialize another object with same class
        Complex c2(c1);
    2. the parameter of a function is a object of class
        see code
    3. the return value of a function is an obeject of class
        see code

    The object of 2. and 3. situation, they are called temp object
        
*/

void Func(Complex x){

}

Complex Func2(){
    Complex c(4);
    return c;
}


class Myclass{
    public:
        int n;
    Myclass(){
        std::cout<<"Myclass Constructor called"<<std::endl;
    }
    Myclass(const Myclass &x){
        std::cout<<"Myclass copy called"<<std::endl;
        n = x.n*2;
    }
};

int main(){
    Complex c1;
    Complex c2(c1);

    Complex x;
    Func(x);

    std::cout<<Func2().real<<std::endl; // therorilly, the copy constructor will be called here, but there
    // actually not. There is one thing called return-value-optimization

    Myclass cl1,cl2;
    cl1.n = 5;
    cl2 = cl1; //dont call copy constructor
    Myclass cl3(cl1); // copy constructor called, cl3.n = 10
    return 0;
}